* 对象：可以是图片，网页或者其他文件
* Web也包含一个基本的HTML文件，该HTML文件包含了若干对象的引用
* 通过URL对每个对象进行引用
* HTTP：超文本传输协议
  * Web的应用层协议
  * CS模式
  * 无状态服务器 ：服务端不维护客户端的状态信息
  * 有状态服务器：使用cookie维护客户信息
  * HTTP连接
    * 非持久HTTP
      * 每个对象都要两个RTT
    * 持久HTTP
      * 非流水线：一次请求和返回的对象只有一个
      * 流水线：前一个对象没回来的时候请求别的对象
  * 请求报文格式
    * 报文格式都是ASC码可读的
    * GET是head和body都要，但是POST是上载，只要head，head会提供索引信息
  * 响应报文格式
    * 应用层需要自己区分报文头和报文尾
    * 有状态码之类的
  * Cookie：
    * 第一次向服务器发出请求的时候，服务器会在response报文中通过setCookie返回cookie的首部行，然后客户端就在本地保存下来，下次向服务器请求的时候，就带上首部行
  * web缓存(代理服务器)
    * 不访问原始服务器，就可以满足客户的请求
* FTP：
  * 分为控制连接和数据传输连接
* 电子邮件
  * 三个组成部分
    * 用户代理
    * 邮件服务器
    * 简单邮件传输协议：SMTP
  * 通过用户代理软件才能访问电子邮件这个应用，所以软件就是所谓的代理
  * 前两跳推(用户代理->邮件服务器, 邮件服务器->目标邮件服务器)，后一跳拉(邮件服务器->用户代理，可以使用的协议：POP3; IMAP; HTTP)
* DNS
  * 需要解决的问题：
    * 如何命名设备
    * 如何完成名字到IP地址的转换
    * 如何维护：增加或者删除一个域，需要在域名系统中做哪些工作
  * 主要思路：
    * 分层的、基于域的命名机制
    * 若干分布式的数据库完成名字到IP地址的转换
    * 运行在UDP之上端口为53的应用服务
    * 核心在Internet功能，但是以应用层协议实现
  * 主要目的
    * 实现主机名-IP地址的转换
    * 其他目的
      * 主机别名到规范名字的转换(别名是为了用户访问，规范名字是便于管理)
      * 邮件服务器别名到邮件服务器的正规名字的转换
      * 负载均衡
  * 域的划分是逻辑的，和物理网络没有关系
  * 只设置一个名字服务器的问题
    * 可靠性不足
    * 扩展性不足
    * 难以进行维护
  * 区域
    * 区域的划分由区域管理者自己决定
    * 将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分
    * 名字服务器：
      * 每个区域都有一个名字服务器，维护它所管辖的权威信息
      * 名字服务器被允许放置在区域之外，以保障可靠性、
    * 区域名字服务器维护资源记录
      * 作用：维护域名-IP的映射关系
      * 位置：Name Server的分布式数据库之中
    * RR格式
      * Domain_name：域名
      * TTL
      * Class：对于Internet，值为IN
        * CH（Chaosnet）类：1970 年代MIT研究员研发的小型网络协议
      * Value值：可以是数字，域名或者ASCII串
      * Type串别：规定了Name和Value表示的含义
  * 上层的域需要有一个指针指向下层的域
  * 缓存是为了性能，删除是为了一致性
  * 上层需要知道下层的信息包括
    * 子域的名称和子域对应的服务器的名字是什么
    * 子域服务器对应的IP地址是什么
  * 一台设备上网需要知道的信息
    * IP地址
    * 所在的子网掩码
    * 网关
    * local name server
  * 查询的方式
    * 递归：一路问到顶
    * 迭代：踢皮球
  * 维护
    * 维护两条信息
      * 子域的名字到名字服务器的名字
      * 名字服务器的名字到ip地址
* P2P应用
  * 在文件下载的场景下，p2p应用有更多优势
  * 管理模式
    * 非结构化：任意PEER节点之间进行连接，称之为overlay(节点之间存在邻居关系)
      * 集中式目录：节点上线的时候需要向中心服务器告知自己上线，并汇报自己的ip地址和拥有的资源，服务器保存资源的索引，以便于用户查询
      * 完全分布式：查询使用泛洪的方式进行，overlay网络的建立通过配置文件发ping，收到ping以后回复信息，发ping的再随机挑选以建立连接
      * 混合体：建立组长机制，查询文件的时候有描述匹配和使用哈希表进行了维护
      * 例子：bt：文件被分为一个个的块，然后网络中的peer节点发送和接受文件块，相互服务
    * 结构化：节点之间呈环状或者树状
* 视频流化服务
  * 视频流量占据互联网大部分的带宽
  * 挑战：客户端的异构性
    * 采用CDN进行解决
  * 解决方案：分布式的，应用层面的基础设施
  * 音视频在网络中传输要进行压缩
  * 存储视频的流化服务
    * 边下边看，从缓冲区取出内容给客户端
  * DASH：把一个视频切成不同的码率，然后每个块根据预先部署的要求分布在不同的服务器当中
    * 根据不同的情况动态的从告示文件中指明的服务器取出不同的视频块
  * 内容提供网络遇到的问题
    * 中间网络的条数比较多
    * 重复流量多
    * 单点故障，可靠性不足
    * 性能瓶颈
    * 周边网络拥塞
  * CDN：解决内容提供网络问题的方法
    * 具体方法：在全网部署缓存节点，存储服务内容，通过域名解析重定向就近为用户提供服务，提高用户的体验
    * 具体方案
      * enter deep：将CDN服务器深入到接入网
        * 这种方案需要布置很多服务器，维护需要成本
      * bring home：部署在少数关键位置
